# Руководство по квантовым вычислениям
## Введение
Наверняка каждый уже слышал хотя бы раз в своей жизни про квантовые технологии, новые суперкомпьютеры, которые по производительности превосходят классические во много-много раз и про новое светлое будущее, которое нас ждет. 

Во-первых, все не совсем так, как нам хочется. Квантовые компьютеры далеко не всесильны и хорошо показывают себя лишь в некоторых областях. Во-вторых, это все пока что (на момент написания этого гайда) лишь в теории. Дело в том, что нынешние квантовые компьютеры не обладают достаточной мощностью для реализации многих полезных алгоритмов, из-за чего многие вещи приходится выполнять пока что на классических компьютерах. Но будущее не за горами, прогресс идет и очень скоро квантовые компьютеры заменят классические в некоторых узконаправленных задачах. 

Уже сейчас каждый желающий может запустить в браузере облачный сервис с квантовым компьютером, написать какой-нибудь код и получить результат. И это руководство вам в этом поможет. 

Первая часть написана для теоретического ознакомления с квантовыми вычислениями. Она очень пригодится тем, кто мало знаком с этой темой или тем, кто плохо понимает как это вся система работает и устроена в принципе. 

Далее, во второй части, мы перейдем к практике нашего руководства. На примерах посмотрим, как работает квантовый компьютер, реализуя определения и методы, описанные в предыдущей главе. Напишем пару небольших программ и протестируем их. 

В третьей части мы постараемся разобраться с квантовыми сетями: что это, как это работает и что нам следует ожидать. Тема интересная, пусть и пока что мало изученная, но тем не менее разобраться определенно стоит. Приступим!


# Часть I. Основы.
## 1. Кубиты. Суперпозиция.

Чтобы с головой окунуться в славный мир квантовых технологий, нам очень сильно помогут основные определения и понятия, на которых все основано. Начнем с самых простых вещей – кубитов (в англ. Qubits).

Наверняка вы уже хорошо знакомы с битами и прекрасно понимаете, что это такое и как они работают. Бит – это единица информации. В квантовых вычислениях в нашем распоряжении тоже есть единицы информации, но называются они кубитами. Существенное отличие битов от кубитов состоит в том, что первые могут находиться лишь в двух состояниях – 0 или 1. Кубиты, в свою очередь, точно так же могут находится в этих двух состояниях с одним маленьким но: у кубитов, ко всему прочему, существует вероятность нахождения в одном из двух состояний. Это значит, что кубит может представлять 0, 1 или любую пропорцию 0 и 1 в суперпозиции обоих состояний с определенной вероятностью быть 0 и определенной вероятностью быть 1.

Состояние кубита описывается вектором в двумерном комплексном гильбертовом пространстве:
<p align="center">
<img width="278" alt="image" src="https://github.com/user-attachments/assets/2b51433a-220e-4394-8a7c-e58e307c6a5f" />
</p>
где:

- |ψ⟩ — состояние кубита,
- |0⟩ и |1⟩ — базисные состояния (аналоги классических 0 и 1),
- α и β — комплексные числа, называемые амплитудами вероятностей, удовлетворяющие условию нормировки:

<p align="center">
<img width="239" alt="image" src="https://github.com/user-attachments/assets/38022ce6-6290-4da8-b2cb-6c81ad2fed07" />
</p>

Здесь |α|² — вероятность нахождения кубита в состоянии |0⟩, а |β|² — вероятность нахождения в состоянии |1⟩.   

Когда кубит измеряется, его состояние "коллапсирует" в одно из базисных состояний с вероятностью, определяемой квадратами модулей амплитуд. Например, для состояния:
<p align="center">
<img width="325" alt="image" src="https://github.com/user-attachments/assets/4dae9827-b35d-4df5-bff8-e468b2fb36ba" />
</p>
Вероятности измерения будут:
<p align="center">
<img width="359" alt="image" src="https://github.com/user-attachments/assets/d0c9c805-f9c7-479f-bc21-6fa22fa434dd" />
</p>

Вполне возможно, что кубит, у которого вероятность нахождения в состоянии 1 равна 50%, может как содержать в себе некую единицу информации, так и не содержать ее вовсе. Этот феномен называется суперпозиция (в англ. Superposition). 

Суперпозиция позволяет квантовым алгоритмам обрабатывать информацию за малую долю времени, которое потребовалось бы даже самым быстрым классическим системам для решения определенных задач.

- Количество информации, которую может представить система кубитов, растет экспоненциально. Информация, которую могут легко представить 500 кубитов, не была бы возможна даже с более чем 2^500 классическими битами.
- Классическому компьютеру потребовались бы миллионы лет, чтобы найти простые множители 2048-битного числа. Кубиты могли бы выполнить вычисления всего за несколько минут.

Состояние суперпозиции можем наблюдать в реальной жизни: достаточно лишь подбросить монетку. До тех пор, пока монета находится в воздухе и не упадет на какую-либо поверхность, она находится в состоянии суперпозиции. Ведь мы не можем заведомо знать, что будет – орел или решка. И исход каждого из таких событий будет равен 50%, если мы обойдемся без посторонних вмешательств.

Но мы вполне оправданно можем вмешиваться в этот процесс и менять вероятность под наши нужды. В случае с монеткой, мы можем подуть на нее или же примагнитить, чтобы увеличить шансы на благоприятный для нас исход. С кубитами все аналогично, правда подуть на них или примагнитить нам, к сожалению, не удастся. О том, как работать с состоянием суперпозиции, мы обсудим позже. 

## 2. Запутанность. Интерференция.

Обсудим еще парочку важных для нас определений. Первое из них – квантовая запутанность (в англ. Quantum entanglement). Это явление, при котором два или более кубита оказываются связанны таким образом, что если состояние первого кубита было изменено, то оно повлияет на состояния других кубитов, вне зависимости от расстояния между ними. Проще говоря, кубиты ведут себя так, как если бы они «знали» друг о друге и действовали согласованно. 

Для понимания этого процесса вернемся к примеру с монеткой. Возьмем еще одну монетку и скажем, что пусть первая монетка всегда в конечном итоге показывает орел, а вторая – решку. Таким образом мы установили взаимосвязь между ними. И даже если мы улетим далеко-далеко, в другую вселенную, и бросим эти две монетки в одно время (хотя, конечно, это понятие относительное, но отбросим все формальности и предположим, что нам удалось это сделать), то на основании конечного состояния первой монетки мы смело можем делать вывод о конечном состоянии второй монетки. 

Теперь перейдем к интерференции. Квантовая интерференция – это явление, при котором два или более кубита взаимодействуют друг с другом, находясь в состоянии суперпозиции, тем самым влияя на конечные состояния всех кубитов. 

В качестве примера представим гладкий пруд. В руках у нас два камня. И мы бросаем каждый из камней в пруд. Каждый камень создает круговые волны, которые распространяются по поверхности воды от точек, где упали камни. На первый взгляд кажется, что эти волны от двух камней распространяются независимо друг от друга, но на деле это не совсем так. Когда волны встречаются, они взаимодействуют друг с другом и интерферируют: если гребни волн совпадают, то они усиливают друг друга, создавая более высокие волны. Если гребни одной волны совпадают с впадинами другой, то волны подавляются. Здесь мы можем провести аналогию и с кубитами. При взаимодействии друг с другом они могут влиять на состояния других кубитов как положительно, так и отрицательно. 

На этом первую часть гайда можно завершить. Теперь вы знаете основы квантовых вычислений и вы в состоянии понять, что будет происходить дальше. А дальше будет только интереснее!

# Часть II. Квантовые вентили и логические элементы.

Для начала стоит обговорить зачем эта часть нужна в принципе. Дело в том, что при описании квантовых алгоритмов постоянно используются квантовые вентили и логические элементы. И понять что происходит в алгоритме довольно трудно, не зная таких вещей. Потому очень важно познакомить читателя с данным «языком». 

## 1. Опять основы.
Начнем с самого простого. Чтобы начать пользоваться квантовыми вычислениями, необходимо понять как это все представляется с помощью математических формул. 

Так, например, обозначается кубит с состоянием 1: 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/1aaabde3-5ea7-4899-9769-cdc862bab593"/>
</p>

А так выглядит кубит с состоянием 0:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/989f5fb7-d1f1-4c6d-85d2-195aec92748a"/>
</p>

А так выглядит состояние двух кубитов:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/9ae09376-d0e7-4fae-9203-3047be68795e"/>
</p>

Оно вычисляется с помощью тензорного произведения состояний двух других кубитов. 

Очень удобно будет визуализировать состояния кубитов, чтобы понять дальнейшие операции. Так мы можем представить состояния кубитов на сфере Блоха:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/9b0311a1-1146-4585-9ad3-269109b40ebf"/>
</p>


Здесь «+» и «-» - сумма (разность) двух состояний 0 и 1 деленная на корень из двух (т.е. в этих точках у нас возникает суперпозиция).

Также у нас существуют так называемые 4 состояния Белла. Они являются простейшим примером квантовой запутанности. 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/c43dfa8d-8b72-4bb4-aa58-7e7dbc93b329"/>
</p>


## 2. Диаграммы квантовых цепей и вентили.
 
Перейдем теперь на сайт https://quantum.ibm.com/ (В России он, скорее всего, работать не будет, потому воспользуйтесь ВПН). Зарегестрируйтесь, войдите в аккаунт и перейдите в раздел «IBM Quantum Composer». Создав новый файл, вы увидите вот это: 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/6bddc46e-601a-4ab4-b26d-577d8a33fcfb"/>
</p>

Слева у нас расположены все доступные нам квантовые вентили. В центре сверху у нас находится диаграмма цепей. Снизу расположены шкала вероятностей для кубитов и сфера Блоха. Справа можем увидеть представление нашей диаграммы в виде кода на языке, который мы выбрали (из доступных есть Qiskit и OpenQASM). Давайте теперь разбираться подробнее что есть что и как оно работает.

Начнем с диаграммы. Нам сразу же дали в распоряжение 4 кубита (или, как их еще называют, квантовые регистры): q[0], q[1], q[2] и q[3]. Также у нас есть классический регистр c4. Это просто напросто самый обычный бит, который либо содержит единицу информации, либо нет. Никакой суперпозиции. После того, как все операции с кубитами были завершены, полученный результат сохраняется в классическом регистре. Также может быть и такое, что классический регистр понадобиться при реализации какого-либо алгоритма. 

Перейдем к вентилям. 
Квантовые вентили — это базовые элементы квантовых вычислений, которые выполняют операции над кубитами. Каждый квантовый вентиль описывается унитарной матрицей, которая гарантирует, что преобразование сохраняет норму состояния кубита (т.е. сумма вероятностей всех возможных состояний остается равной 1). Унитарная матрица U удовлетворяет условию:
<p align="center">
<img width="143" alt="image" src="https://github.com/user-attachments/assets/d157f7eb-23a8-4877-86f0-5d9f4b07ce7a" />
</p>

Здесь их довольно много, но мы рассмотрим лишь парочку и самые основные. Остальные используются не так часто и при желании всегда можно будет посмотреть информацию о них в других источниках.

1. Преобразование Адамара (Hadamar transformation, H-gate) — преобразование на единичный кубит. Это преобразование приводит кубит в состояние суперпозиции.
   
<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/b888186b-a5f0-4f59-adbc-3e10e1c4401b"/>
</p>

Как вы можете видеть на скриншоте, я применил к первому кубиту преобразование Адамара и он вошел в состояние суперпозиции — вероятность нахождения в состоянии 0 или 1 этого кубита равняется 50%.  

Его матрица:
<p align="center">
<img width="305" alt="image" src="https://github.com/user-attachments/assets/ef2fbf61-41f3-43b3-b5cc-ace719e79134" />
</p>

Действие:
<p align="center">
<img width="711" alt="image" src="https://github.com/user-attachments/assets/1791de77-4504-4f1f-b807-a89a0ad87ff9" />
</p>

Для наглядности и более простого восприятия, я оставил лишь один квантовый регистр. 

Если рассматривать вентиль Адамара относительно поворотов осей, то он будет соответствовать повороту осей X и Z. 

2. Отрицание (NOT gate, Pauli X gate) — поворот состояния относительно оси X на π радиан. По сути это логическое нет. Меняет состояние кубита с 0 на 1 и наоборот.

Его матрица:
<p align="center">
<img width="203" alt="image" src="https://github.com/user-attachments/assets/d8afb87d-3297-4702-aeff-80110ff628e9" />
</p>

Действие:
<p align="center">
<img width="386" alt="image" src="https://github.com/user-attachments/assets/555d594e-52f9-4825-81b6-6733e6ff613d" />
</p>

3. Вентиль Паули Y (Pauli Y gate) — поворот состояний относительно оси Y на π радиан. Вот так это выглядит на сфере Блоха:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/82f45315-6926-4911-88af-aa9d47198fbe"/>
</p>

Его матрица:
<p align="center">
<img width="229" alt="image" src="https://github.com/user-attachments/assets/97e587fa-82c4-435e-8a39-e2128ccf6982" />
</p>

Действие:
<p align="center">
<img width="428" alt="image" src="https://github.com/user-attachments/assets/b6bf6f6a-e0e6-4646-b688-d62b21f2021f" />
</p>

4. Фазовый сдвиг (Pauli Z gate) — поворот состояния относительно оси Z. Это преобразование, которое поворачивает состояние 1 на 180 градусов, т.е. из состояния 1 мы получаем состояние -1. На сфере Блоха это выглядит таким образом:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/0304bd2f-39cb-4d96-8285-7c3e02c5bf4f"/>
</p>

Здесь я подействовал на кубит в состоянии суперпозиции (сделал я это с помощью преобразования Адамара) вентилем Z. Как мы можем видеть, на сфере Блоха сразу же отобразилось, что состояние 1 повернулось на 180 градусов, то есть стало -1. 

Этот гейт не меняет нулевое состояние кубита, но для состояния 1 оно меняет знак.

Его матрица:
<p align="center">
<img width="225" alt="image" src="https://github.com/user-attachments/assets/de1b6365-2656-4ed5-8d8d-58518746cda2" />
</p>

Действие:
<p align="center">
<img width="397" alt="image" src="https://github.com/user-attachments/assets/2d1841e1-5b69-4054-98b5-2d304aedb30c" />
</p>

5. Тождественное преобразование (Identity gate, I gate) — преобразование, которое не меняет состояние кубита. Оно необходимо тогда, когда нам нужно, чтобы состояние кубита не изменялось в какой-то определенный момент времени.

Его матрица:
<p align="center">
<img width="196" alt="image" src="https://github.com/user-attachments/assets/17034057-6c7b-4817-b296-9ec39ef1809f" />
</p>

Действие:
<p align="center">
<img width="355" alt="image" src="https://github.com/user-attachments/assets/ab6806f1-ca37-4736-8283-b1e31731a467" />
</p>
  
6. Контролируемое отрицание (CNOT) — еще одно преобразование, которое пригодится нам при рассмотрении алгоритма квантовой телепортации. Это преобразование работает с двумя кубитами, потому чтобы нам удалось его применить на практике, потребуется два квантовых регистра. Как этот вентиль работает? Для начала он берет первый кубит, который становится «управляющим» (control qubit) и воздействует на второй кубит, который называется «целью» (target qubit). Если состояние управляющего кубита было равно 1, то вентиль CNOT инвертирует состояние кубита цели, т.е. работает как X gate. Иначе, если состояние управляющего кубита было равно 0, то ничего не происходит. Но если управляющий кубит находился в состоянии суперпозиции, то этот вентиль создает запутанность (entanglement).

Его матрица:
<p align="center">
<img width="379" alt="image" src="https://github.com/user-attachments/assets/6a47e16a-694d-4a10-a719-88715bc4d434" />
</p>

Действие:
<p align="center">
<img width="1035" alt="image" src="https://github.com/user-attachments/assets/c9e7f98b-ce52-4c34-956d-8a344c37f634" />
</p>
 
7. Фазовый вентиль (S Gate, Phase Gate) — поворот относительно оси z на угол π/2. При этом преобразовании состояние 0 остается без изменений, а состояние 1 преобретает дополнительную фазу, т.е. совершает поворот на угол π/2 относительно оси z.

Его матрица:
<p align="center">
<img width="197" alt="image" src="https://github.com/user-attachments/assets/39e0b931-6fc0-4954-9056-75b5bbf3740c" />
</p>

Действие:
<p align="center">
<img width="376" alt="image" src="https://github.com/user-attachments/assets/60bc8233-e971-4ce0-9c76-a2bb59155ef7" />
</p>

8. Измерительный гейт (Measurement). На самом деле это не совсем вентиль, но удобнее его воспринимать таковым. Что он делает? Когда мы применяем измерительный вентиль к кубиту в квантовом регистре, он как бы приостанавливает его состояние суперпозиции (если кубит в нем находился, иначе он просто напросто переводит информацию в классический регистр) и вычисляет вероятность состояний этого кубита. На основе вероятностей этих состояний измерительный гейт отправляет на классический регистр одно из значений — 0 или 1. И воспринимается это все теперь как классические биты.
   
Мы обсудили и разобрали все основные квантовые вентили. При желании вы можете разобрать их все, но они не столь важны в нашем пути. Но если все же интересно, то по каждому вентилю вы можете прочитать информацию, кликнув на него правой кнопкой мыши. А теперь перейдем к практике!

# Часть III. Практическое применение полученных знаний.
## 1. Запуск первой программы.

Теперь когда мы знаем все необходимое для написания простеньких программ, давайте приступим к запуску нашей первой программы на квантовом компьютере! 
Я выставил вот такие незатейливые вентили на регистры:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/559b5ba7-dfab-436e-8380-947c6396786e"/>
</p>

Давайте проверим что мы получим в конечном итоге. Нажмем на кнопку «Setup and run». 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/009c94ab-af8e-434d-b0ce-f00b871cc9c1"/>
</p>

Высветится вот такое меню. Слева у нас расположен список доступных нам квантовых компьютеров или симуляторов. Их довольно много, но я выбрал тот, на котором была маленькая очередь, чтобы программа запустилась быстрее. 

Под каждым из компьютеров расположена информация о статусе системы, количестве работ в ожидании, количество кубитов, EPLG и CLOPS.
EPLG — error per layered gate — это коэффициент, который показывает частоту ошибок при выполнении двухкубитных (или более) вентилей в одно и то же время на 100 кубитов (здесь используется именно это число).

CLOPS — это мера того, насколько быстро наши процессоры могут последовательно запускать схемы квантового объема. То есть сколько операций квантового объема эта система способна исполнить за одну секунду. 

Справа у нас 3 строчки. Instance — экземпляр или компьютер, который мы выбрали; Shots — количество итераций, которое наш суперкомпьютер должен будет проделать для нашей программы; Tags — комментарий к нашей программе. Он ничего существенного не дает, но вы можете написать туда что-нибудь и это что-нибудь сможет увидеть другой человек, если заглянет на то, что исполняет (или собирается исполнить) квантовый компьютер или симулятор.

На этом все. Можно смело нажимать кнопочку «Run on ...». После небольшой загрузки мы можем отслеживать процесс работы слева:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/43b79842-1d30-461a-b2bb-c3cc96c3b617"/>
</p>

Поскольку очередь была крайне маленькой, завершилось у меня все за считанные секунды. Давайте взглянем на результат!

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/23b3c226-2a77-4b3e-8712-6a9a8681ed9f"/>
</p>

В quasi_dists отображаются наши результаты измерений. Для состояния 00 вероятность равна 0.4580078125, а для 01 равна 0.5419921875. В metadata отображаются метаданные наших вычислений. Shots — количество итераций. В circuit_metadata отображается дополнительная информация о схеме или настройках вычисления. Мы ничего сверхъестественного в нашу программу не добавляли, а потому эта строчка пуста. readout_mitigation_overhead отвечает за накладные расходы на коррекцию считывания. Метод коррекции считывания мы не применяли, потому эта строка вернула нам 1. И readout_mitigation_time показывает время, затраченное на исполнение вычислений, а именно 0.014736633995198645 секунд. 

Запустим нашу программу еще раз и посмотрим на полученные результаты. В этот раз я выставил 4096 итераций.

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/ee5fd7ba-40cb-4a78-8f80-546f5cfd6ec4"/>
</p>

Здесь результаты уже более точные и приближенные к реальности: вероятность попадания в состояние 00 составило 0.49, а в состояние 01 — 0.51. И чем больше у нас будет итераций, тем более наши вероятности будут точны и приближены к теоретически ожидаемому результату.

## 2. Квантовая телепортация.

Перейдем, наконец, к самому интересному — квантовой телепортации. Это процесс в квантовой механике, который позволяет передавать информацию (в нашем случае состояния кубитов) из одного места в другое с помощью состояний суперпозиции и квантовой запутанности кубитов между отправителем и получателем. Давайте разберемся как этот процесс работает.  

Изначально у нас есть два человека, скажем, Петя и Вася. Петя хочет передать Васе некоторое закодированное квантовым состоянием сообщение. Для передачи такого рода сообщений нам необходима квантовая система, состоящая как минимум из трех квантовых регистров (2 регистра контролирует Петя, 1 для Васи) и двух классических регистров для передачи результатов измерений. Вообще говоря, из-за использования классических регистров в этом процессе он не совсем является телепортацией, как его все называют, и не выполняется быстрее скорости света, но в теории все равно является очень быстрым способом передачи информации между пользователями.

Чтобы Петя передал информацию Васе, первый кубит должен находится в некотором состоянии (т.е. содержать информацию, которую хочет передать Петя), которое мы будем передавать с помощью второго кубита на третий. Для этого мы последовательно выполняем следующие шаги:

1)  Мы применяем преобразование Адамара ко второму кубиту.
2) Применяем вентиль CNOT к второму кубиту, чтобы ввести третий кубит в состояние квантовой запутанности со вторым кубитом.
3) Затем мы запутываем первый кубит со вторым при помощи того же вентиля CNOT.
4) Применяем преобразование Адамара на первый кубит.
5) Измеряем первые два кубита и передаем по классическому регистру информацию Васе.
6) Вася же теперь должен применить одну из операций в зависимости от полученных данных, чтобы восстановить исходное состояние. По такому принципу Вася должен будет применить определенное преобразование:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/7ba5fff6-0a33-4def-8f08-00930e8b294d"/>
</p>

Вот так должна выглядеть конечная схема алгоритма:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/aba39fd7-50e8-4a8f-8b61-67308f5edeaf"/>
</p>


Про единичные преобразования я ничего не говорил, но используются они лишь для того, чтобы упорядочить выполнение программы и она выглядела проще. 
Вот сам код программы:

```OpenQASM
OPENQASM 2.0;
include "qelib1.inc";

qreg q[3];
creg c0[1];
creg c1[1];
h q[1];
cx q[1], q[2];
cx q[0], q[1];
id q[2];
h q[0];
measure q[1] -> c1[0];
id q[2];
measure q[0] -> c0[0];
if (c1 == 1) x q[2];
if (c0 == 1) z q[2];
```
Через эмулятор IBM изобразить передачу сообщений довольно проблематично, потому для того, чтобы продемонстрировать работу алгоритма воспользуемся этим [ресурсом](https://algassert.com/quirk#circuit={%22cols%22:[[1,%22H%22],[1,%22%E2%80%A2%22,1,1,%22X%22],[%22%E2%80%A6%22,%22%E2%80%A6%22,1,1,%22%E2%80%A6%22],[%22%E2%80%A6%22,%22%E2%80%A6%22,1,1,%22%E2%80%A6%22],[%22~87lj%22],[%22Bloch%22],[%22%E2%80%A2%22,%22X%22],[%22H%22],[%22Measure%22,%22Measure%22],[1,%22%E2%80%A2%22,1,1,%22X%22],[%22%E2%80%A2%22,1,1,1,%22Z%22],[1,1,1,1,%22Bloch%22],[1,1,1,1,%22~f7c0%22]],%22gates%22:[{%22id%22:%22~87lj%22,%22name%22:%22message%22,%22circuit%22:{%22cols%22:[[%22e^-iYt%22],[%22X^t%22]]}},{%22id%22:%22~f7c0%22,%22name%22:%22received%22,%22matrix%22:%22{{1,0},{0,1}}%22}]}).

Здесь наглядно показано при помощи сферы Блоха как мы передаем некоторое сообщение с первого регистра на третий. Обратите внимание, что передача сообщения сохраняется с точностью до фазового сдвига.

Собственно вот и все! Таким казалось бы простым алгоритмом мы «телепортируем» информацию от одного пользователя к другому. Фантастика!

## 3. Сверхплотное кодирование.

Сверхплотное кодирование является противоположной задачи о квантовой телепортации. Задача квантовой телепортации состояла в передаче одного кубита (вернее его состояния) с помощью двух классических бит. Задача сверхплотного кодирования обратна — нам необходимо передать два классических бита с помощью одного кубита. 

Вернемся к нашим двум товарищам — Пете и Васе. Пусть изначально у нас имеется пара запутанных кубитов. Первый кубит для Пети, второй — для Васи. 

При помощи лишь двух кубитов Петя может передавать Васе два бита классической информации по такому принципу:

1. Если Петя хочет передать Васе битовую строку «00», то он ничего не делает со своим кубитом и ждет пока Вася его декодирует;
2. Если он хочет передать битовую строку «01», то он применяет X gate (NOT) к своему кубиту;
3. Если Петя хочет передать битовую строку «10», то он применяет фазовый сдвиг (Z gate) к своему кубиту;
4. И, наконец, если он хочет передать битовую строку «11», то он применяет X gate и Z gate последовательно к своему кубиту.

Таким образом внимательный читатель сразу заметит, что мы получили состояния Белла. И этот читать окажется прав! Действительно, это совсем нетрудно проверить, зная реализации всех используемых вентилей в матричном виде.

Поскольку кубиты у нас находятся в состоянии запутанности, то Вася вне зависимости от растояния от Пети все равно сможет получить состояние кубита, которое хотел донести до него Петя и затем декодировать его.

А каким образом он будет декодировать полученное состояние кубита? А все довольно просто. Вася применит к квантовым регистрам вентиль CNOT, где первый кубит является управляющим, а затем применяет преобразование Адамара к этому же кубиту. После этого Вася смело может измерять состояние обоих кубитов, чтобы получить закодированное сообщение Пети.

Вот так должна выглядеть конечная схема алгоритма:

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/892ea67e-8cb2-4be4-955c-7d9986586e69"/>
</p>

В этот раз давайте проверим результат работы не только на симуляторе квантового компьютера, но и на реальном, и сравним полученные результаты. 

Вот что мы получим при запуске нашей программы на симуляторе: 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/8411670d-5768-4004-a9a7-c891e4aa1971"/>
</p>

И на квантовом компьютере: 

<p align="center">
 <img src="https://github.com/RPogodin/ck-quantum/assets/102846577/c7ec6e57-93b2-4175-b650-34835c3822ab"/>
</p>

Поскольку очередь на квантовый компьютер всего довольно большая, приходится ждать по 4 и более часов на то, чтобы произвести желаемые вычисления. 

На симуляторе мы можем видеть, что мы имеем 100% вероятность измерить правильное сообщение, а вот на квантовом компьютере все не так хорошо. Шанс измерить правильное сообщение составил 90%. Все это происходит из-за так называемой декогеренции и погрешностей в вентилях. 

Декогеренция — это разрушение состояния суперпозиции кубитов, если говорить простыми словами. Оно может быть вызвано разными факторами, начиная от ошибок в аппаратной реализации и заканчивая взаимодействием с окружающей средой (квантовые системы очень чувствительны к внешним возмущениям, таким как электромагнитное излучение, тепловые флуктуации и прочие виды шумов). 

## 4. Квантовое преобразование Фурье.
### Введение
Преобразование Фурье встречается во многих областях: в классических вычислениях, в областях от обработки сигналов до сжатия данных и теории сложности. Квантовое преобразование Фурье (QFT) — это квантовая реализация дискретного преобразования Фурье по амплитудам волновой функции. Оно является частью многих квантовых алгоритмов, в частности, факторизационного алгоритма Шора и квантовой оценки фазы.

Дискретное преобразование Фурье действует на вектор (x0, x1, …, xN−1) и отображает его в вектор (y0, y1, …, yN −1) по формуле

<p align="center">
 <img src="https://github.com/user-attachments/assets/8a3c41c4-fd04-49db-b59a-9c6700e8bae2"/>
</p>

где

<p align="center">
 <img src="https://github.com/user-attachments/assets/81e5c40d-3165-4763-8988-ce8a49952e87"/>
</p>

Аналогично квантовое преобразование Фурье действует на квантовое состояние

<p align="center">
 <img src="https://github.com/user-attachments/assets/a968a19c-3451-405f-bf89-ef10b03e16e8"/>
</p>

и отображает его в квантовое состояние

<p align="center">
 <img src="https://github.com/user-attachments/assets/68b5d0c0-f8df-48b7-8c07-068ed9ce72a8"/>
</p>

по формуле

<p align="center">
 <img src="https://github.com/user-attachments/assets/cc958ef3-9c51-4089-a945-7be64641a44d"/>
</p>

Обратите внимание, что это преобразование затронуло только амплитуды состояния.

Это также можно выразить в виде отображения:

<p align="center">
 <img src="https://github.com/user-attachments/assets/70f200bd-6575-4b53-8c72-2a79901e7c18"/>
</p>

или унитарной матрицы

<p align="center">
 <img src="https://github.com/user-attachments/assets/77160e12-4e0d-4fb7-aaf4-8483779b3646"/>
</p>

### Интутивное понимание преобразования Фурье
Квантовое преобразование Фурье (QFT) делает преобразования между двумя базисами, вычислительным (Z) базисом и базисом Фурье. H-gate — это однокубитный QFT, и он преобразует состояние Z-базиса |0⟩ и 1⟩ в состояния X-базиса |+⟩ и |−⟩. Точно так же все многокубитные состояния в вычислительном базисе имеют соответствующие состояния в базисе Фурье. QFT — это просто функция, которая преобразует один базис в другой.

### Подсчет в базисе Фурье

При обычных вычислениях мы храним числа в двоичном виде, используя состояния |0⟩ и |1⟩:

![1_ZiReRgblkLfvI5LN53wMWA](https://github.com/user-attachments/assets/cf4beb9c-d751-4089-8866-510dedd651ec)

Обратите внимание на частоту, с которой изменяются различные кубиты; самый левый кубит переворачивается с каждым приращением числа, следующий — с каждыми 2 приращениями, третий — с каждыми 4 приращениями и т. д. 
В базисе Фурье мы храним числа, используя различные вращения вокруг оси Z:

![1_YlFo-6jH6Sm1HJkmWY73mA](https://github.com/user-attachments/assets/ede26520-c15f-4f6b-b37a-7a75b2fe753b)

Число, которое мы хотим сохранить, определяет угол, на который каждый кубит поворачивается вокруг оси Z. В состоянии |0~⟩ все кубиты находятся в состоянии |+⟩. Как видно из примера выше, чтобы закодировать состояние |5~⟩ на 4 кубитах, мы повернули самый левый кубит на 5/16 полных оборотов (радиан). Следующий кубит поворачивается на два угла (10/16×2 π радиан, или 10/16 полных оборотов), затем этот угол удваивается для кубита после этого и так далее.

Опять же, обратите внимание на частоту, с которой меняется каждый кубит. Самый левый кубит (кубит 0) в этом случае имеет самую низкую частоту, а самый правый — самую высокую.

###  Пример 1: 1-кубитный QFT

Рассмотрим, как оператор QFT, определенный выше, действует на одно кубитное состояние |ψ⟩ = α|0⟩ + β|1⟩. В этом случае x0 = α, x1 = β и N = 2. Тогда

<p align="center">
 <img src="https://github.com/user-attachments/assets/15a39e7f-7712-4b26-a923-0ba373b266d8"/>
</p>

таким образом, конечный результат — это состояние

<p align="center">
 <img src="https://github.com/user-attachments/assets/6a6a6401-f656-436d-b884-c4f23137b72b"/>
</p>

Эта операция как раз является результатом применения оператора Адамара (H) к кубиту:

<p align="center">
 <img src="https://github.com/user-attachments/assets/14ce7f60-3ac2-43d5-996c-5aee753575db"/>
</p>

Если мы применим оператор H к состоянию |ψ⟩ = α|0⟩ + β|1⟩, то получим новое состояние:

<p align="center">
 <img src="https://github.com/user-attachments/assets/825bda86-07bf-4ec7-abbc-ffbb96c1b55c"/>
</p>

Обратите внимание, как вентиль Адамара выполняет дискретное преобразование Фурье для N = 2 над амплитудами состояния.

### Квантовое преобразование Фурье
Так как же выглядит квантовое преобразование Фурье для больших N?

Рассмотрим формальное определение, оно довольно сложно и не обязательно для дальнейшего понимания алгоритма. Давайте выведем преобразование для N = 2^n , где QFT действует на состояние |x⟩ = |x1, …, xn⟩, где x1 — самый старший бит.

<p align="center">
 <img src="https://github.com/user-attachments/assets/7c101038-ca6a-418a-ac8a-99e5c6585550"/>
</p>

Это математическое описание анимации, которую мы видели ранее:

![1_YlFo-6jH6Sm1HJkmWY73mA](https://github.com/user-attachments/assets/fea27b78-d9ad-428a-9c89-3a8945a200a1)

### Квантовая схема QFT
Схема, реализующая QFT, использует два вентиля. Первый из них — это однокубитный вентиль Адамара H, который вы уже знаете. Из примера 1 выше вы уже видели, что действие H на однокубитное состояние |xk⟩ равно

<p align="center">
 <img src="https://github.com/user-attachments/assets/118a7abc-92e7-4039-8f9d-170b2c4b1a91"/>
</p>

Вторым является двухкубитное управляемое вращение CROT, матрица которого задаеться как

<p align="center">
 <img src="https://github.com/user-attachments/assets/128b042d-0a32-4d2b-9376-b4cb8260e4a7"/>
</p>

где

<p align="center">
 <img src="https://github.com/user-attachments/assets/49566da6-d124-476d-afa5-2d498489ff1a"/>
</p>

Действие CROT на двухкубитное состояние |xl xj⟩, где первый кубит является управляющим, а второй — целевым, задается выражением

<p align="center">
 <img src="https://github.com/user-attachments/assets/05443dc7-8365-4599-a62c-c30e5d2afa07"/>
</p>

Ниже показана схема, реализующая n-кубитный QFT с учетом этих двух вентилей.

<p align="center">
 <img src="https://github.com/user-attachments/assets/9c875baf-1418-46c4-82a2-5902df7501d7"/>
</p>

Схема работает следующим образом. Мы начинаем с n-кубитного входного состояния |x1, x2, …, xn⟩.

1. После первого вентиля Адамара на кубите 1 состояние преобразуется из входного состояния в

<p align="center">
 <img src="https://github.com/user-attachments/assets/496d4d5d-a133-4648-acc9-22290afe5ede"/>
</p>

2. После вентиля UROT2 на кубите 1, контролируемом кубитом 2, состояние преобразуется в

<p align="center">
 <img src="https://github.com/user-attachments/assets/5cedbb78-7044-41da-970e-8940f472f5e0"/>
</p>

3. После применения последнего вентиля UROTn к кубиту 1, контролируемому кубитом n, состояние становится

<p align="center">
 <img src="https://github.com/user-attachments/assets/d711f5ac-603a-4209-94d4-31a2058ec035"/>
</p>

4. Отмечая, что

<p align="center">
 <img src="https://github.com/user-attachments/assets/ce75f9ee-31f1-4ace-bb24-41b90a039e4f"/>
</p>

5. Мы можем записать вышеуказанное состояние как

<p align="center">
 <img src="https://github.com/user-attachments/assets/a5d940ff-8497-49a9-a110-89d557bf6111"/>
</p>

6. После применения аналогичной последовательности вентилей для кубитов 2…n мы находим конечное состояние:

<p align="center">
 <img src="https://github.com/user-attachments/assets/13327fa8-126a-4806-98a2-217597fd7a73"/>
</p>

что в точности соответствует QFT входного состояния, полученной выше, с той оговоркой, что в выходном состоянии порядок кубитов обратный.

### Пример 2: 3-кубитный QFT

Шаги создания схемы для |y3 y2 y1⟩ = QFT8|x3 x2 x1⟩ будут следующими:

1. Применить вентиль Адамара к |x1⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/dd652ea9-d690-4e28-a01d-8e353291d468"/>
</p>

2. Применить вентиль UROT2 к |x1⟩ в зависимости от |x2⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/3fee0237-4741-4b01-b3a6-04b663d28d43"/>
</p>

3. Применить вентиль UROT3 к |x1⟩ в зависимости от |x3⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/2a328bf6-7095-4743-b194-6febbd3bb77b"/>
</p>

4. Применить вентиль Адамара к |x2⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/c21749dc-fbc9-47f0-b2ac-e5259964d314"/>
</p>

5. Применить вентиль UROT2 к |x2⟩ в зависимости от |x3⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/f1c22de9-84b6-457c-bf9d-2debb5038825"/>
</p>

6. Применить вентиль Адамара к |x3⟩

<p align="center">
 <img src="https://github.com/user-attachments/assets/4d033716-eded-40ef-a571-a1b99f442f3e"/>
</p>

Имейте в виду обратный порядок выходного состояния относительно желаемого QFT. Поэтому мы должны поменять местами порядок кубитов (в данном случае поменять местами y1 и y3).

### Некоторые замечания о форме схемы QFT
Приведенный выше пример демонстрирует очень полезную форму QFT для N = 2^n. Обратите внимание, что только последний кубит зависит от значений всех остальных входных кубитов, а каждый последующий бит все меньше и меньше зависит от входных кубитов. Это становится важным в физических реализациях QFT, где связи ближайших соседей проще достичь, чем связи дальних кубитов.

Кроме того, по мере того, как схема QFT становится больше, все больше времени тратится на выполнение все более незначительных поворотов. Оказывается, мы можем игнорировать повороты ниже определенного порога и все равно получать приличные результаты, это известно как приближенный QFT. Это также важно в физических реализациях, поскольку уменьшение количества операций может значительно снизить декогеренцию и потенциальные ошибки вентиля.

### Реализация алгоритма в Qiskit

Проще построить схему, реализующую QFT с перевернутыми кубитами, а затем поменять их местами; мы начнем с создания функции, которая правильно вращает наши кубиты:

```
def qft_rotations(circuit, n):
    if n == 0: # Exit function if circuit is empty
        return circuit
    n -= 1 # Indexes start from 0
    circuit.h(n) # Apply the H-gate to the most significant qubit
    for qubit in range(n):
        # For each less significant qubit, we need to do a
        # smaller-angled controlled rotation: 
        circuit.cp(pi/2**(n-qubit), qubit, n)
```

Давайте посмотрим, как это выглядит:

```
qc = QuantumCircuit(4)
qft_rotations(qc,4)
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/f4cf4c99-5baf-478c-a3c3-814890360c56"/>
</p>

Отлично! Это первая часть нашего QFT. Теперь мы правильно повернули самый значимый кубит, нам нужно правильно повернуть второй по значимости кубит. Затем нам нужно разобраться с третьим по значимости и так далее. Но зачем писать еще код?

Когда мы дойдем до конца нашей qft_rotations()функции, мы сможем использовать тот же код, чтобы повторить процесс для следующих n-1 кубитов:

```
def qft_rotations(circuit, n):
    """Performs qft on the first n qubits in circuit (without swaps)"""
    if n == 0:
        return circuit
    n -= 1
    circuit.h(n)
    for qubit in range(n):
        circuit.cp(pi/2**(n-qubit), qubit, n)
    # At the end of our function, we call the same function again on
    # the next qubits (we reduced n by one earlier in the function)
    qft_rotations(circuit, n)
```

Давайте посмотрим, как это выглядит:

```
qc = QuantumCircuit(4)
qft_rotations(qc,4)
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/a9f507d1-eb7f-49c6-91e8-8a529701e99c"/>
</p>

Наконец, нам нужно добавить свопы в конце функции QFT, чтобы соответствовать определению QFT. Мы объединим это в финальную функцию qft():

```
def  swap_registers ( circuit, n ): 
    для кубита в  диапазоне (n// 2 ): 
        circuit.swap(qubit, n-qubit- 1 ) 
    return circuit 

def  qft ( circuit, n ): 
    """QFT на первых n кубитах в circuit"""
     qft_rotations(circuit, n) 
    swap_registers(circuit, n) 
    return circuit 
```

Давайте посмотрим, как это выглядит:

```
qc = QuantumCircuit(4)
qft(qc,4)
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/f8dc2702-8ac3-4ced-bb41-5327313d749d"/>
</p>

Теперь мы хотим продемонстрировать, что эта схема работает правильно. Для этого мы должны сначала закодировать число в вычислительном базисе. Мы знаем, что число 5 в двоичном виде равно 101. Давайте закодируем это в наших кубитах:

```
# Create the circuit
qc = QuantumCircuit(3)

# Encode the state 5
qc.x(0)
qc.x(2)
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/a24f790f-be0e-4a1d-8401-b3b25f48b7c6"/>
</p>

Давайте проверим состояния кубита с помощью симулятора aer:

```
sim = Aer.get_backend("aer_simulator")
qc_init = qc.copy()
qc_init.save_statevector()
statevector = sim.run(qc_init).result().get_statevector()
plot_bloch_multivector(statevector)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/82ec8d67-6dfb-46b5-a7db-ca78af1b362d"/>
</p>

Наконец, давайте воспользуемся нашей функцией QFT и посмотрим конечное состояние наших кубитов:

```
qft(qc,3)
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/e458ffe8-2ff9-4f9c-84b2-54dc57ecdd8b"/>
</p>

```
qc.save_statevector()
statevector = sim.run(qc).result().get_statevector()
plot_bloch_multivector(statevector)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/650d8ea8-322d-4645-8083-62b92d7f2f73"/>
</p>

Мы видим, что наша функция QFT сработала правильно. Сравнивая состояние |0~⟩=|+++⟩, кубит 0 был повернут на 5/8 полного оборота, кубит 1 на 10/8 полных оборотов (что эквивалентно 1/4 полного оборота), а кубит 2 на 20/8 полных оборотов (что эквивалентно 1/2 полного оборота).

### Запуск QFT на реальном квантовом компьютере
Если бы мы попытались запустить схему в конце на реальном устройстве, результаты были бы совершенно случайными, поскольку все кубиты находятся в равной суперпозиции |0⟩ и |1⟩. Если мы хотим продемонстрировать и исследовать работу QFT на реальном оборудовании, мы можем вместо этого создать состояние |5~⟩, показанное в конце предыдущего раздела, запустить QFT в обратном порядке и убедиться, что выход — это состояние |5⟩, как и ожидалось.

Во-первых, давайте воспользуемся Qiskit, чтобы легко обратить нашу операцию QFT:

```
def inverse_qft(circuit, n):
    """Does the inverse QFT on the first n qubits in circuit"""
    # First we create a QFT circuit of the correct size:
    qft_circ = qft(QuantumCircuit(n), n)
    # Then we take the inverse of this circuit
    invqft_circ = qft_circ.inverse()
    # And add it to the first n qubits in our existing circuit
    circuit.append(invqft_circ, circuit.qubits[:n])
    return circuit.decompose() # .decompose() allows us to see the individual gates
```

Теперь давайте переведем наши кубиты в состояние |5~⟩:

```
nqubits = 3
number = 5
qc = QuantumCircuit(nqubits)
for qubit in range(nqubits):
    qc.h(qubit)
qc.p(number*pi/4,0)
qc.p(number*pi/2,1)
qc.p(number*pi,2)

qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/d0451469-d5de-4de3-b6a2-07175d9b9d36"/>
</p>

И мы видим, что это действительно приводит к состоянию Фурье |5~⟩:

```
qc_init = qc.copy()
qc_init.save_statevector()
sim = Aer.get_backend("aer_simulator")
statevector = sim.run(qc_init).result().get_statevector()
plot_bloch_multivector(statevector)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/4c41c0ab-20fc-42ee-9213-03cb45736a67"/>
</p>

Наконец, применим наш обратный QFT:

```
qc = inverse_qft(qc, nqubits)
qc.measure_all()
qc.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/14757704-30bc-41f4-b8c8-49972b8fd518"/>
</p>

```
# Load our saved IBMQ accounts and get the least busy backend device with less than or equal to nqubits
IBMQ.load_account()
provider = IBMQ.get_provider(hub='ibm-q')
backend = least_busy(provider.backends(filters=lambda x: x.configuration().n_qubits >= nqubits 
                                       and not x.configuration().simulator 
                                       and x.status().operational==True))
print("least busy backend: ", backend)
```

```
shots = 2048
transpiled_qc = transpile(qc, backend, optimization_level=3)
job = backend.run(transpiled_qc, shots=shots)
job_monitor(job)
```

```
counts = job.result().get_counts()
plot_histogram(counts)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/ce9b7cbd-376f-4f86-8b14-a868617aa235"/>
</p>

Мы видим, что наивысшая вероятность исхода — 101.

## 5. Оценка квантовой фазы.
### Введение
Оценка квантовой фазы — одна из важнейших подпрограмм в квантовых вычислениях. Она служит центральным строительным блоком для многих квантовых алгоритмов. Цель алгоритма заключается в следующем:

При наличии унитарного оператора U алгоритм оценивает θ в U|ψ⟩= exp(2πιθ)|ψ⟩. Здесь |ψ⟩ — собственный вектор, а exp(2πιθ) — соответствующее собственное значение. Поскольку U унитарен, все его собственные значения имеют норму 1.

### Квантовая схема 
Ниже показана общая квантовая схема для оценки фазы. Верхний регистр содержит t «подсчитывающих» кубитов, а нижний содержит кубиты в состоянии |ψ⟩:

<p align="center">
 <img src="https://github.com/user-attachments/assets/080902a9-6b93-444d-8256-9b579e63ee42"/>
</p>

### Интутивное понимание алгоритма оценки квантовой фазы
Алгоритм квантовой оценки фазы использует фазовый откат для записи фазы U (в базисе Фурье) в t кубитов в счетном регистре. Затем мы используем обратный QFT для перевода этого из базиса Фурье в вычислительный базис, который мы можем измерить.

Мы помним (из главы QFT), что в базисе Фурье самый верхний кубит совершает один полный оборот при счете между 0 и 2t . Чтобы сосчитать до числа x между 0 и 2t , мы поворачиваем этот кубит на x/2t вокруг оси z. Для следующего кубита мы поворачиваем на 2x/2t , затем на 4x/2t для третьего кубита.

<p align="center">
 <img src="https://github.com/user-attachments/assets/e37cb3bb-63f0-41e4-ba3c-5f15904c6848"/>
</p>

Когда мы используем кубит для управления U-вентилем, кубит будет поворачиваться (из-за отдачи) пропорционально фазе exp(2ιπθ) . Мы можем использовать последовательные CU-вентили, чтобы повторить это вращение соответствующее количество раз, пока не закодируем фазу тета как число между 0 и 2t в базисе Фурье.

Затем мы просто используем QFT†, чтобы преобразовать это в вычислительный базис.

### Математическая основа
Как упоминалось выше, эта схема оценивает фазу унитарного оператора U. Она оценивает θ в U|ψ⟩= exp(2πιθ), где |ψ⟩ — собственный вектор, а exp(2πιθ) — соответствующее собственное значение. Схема работает в следующих шагах:

1. Счетный регистр:
|ψ ⟩ находится в одном наборе кубитных регистров. Дополнительный набор из n кубитов образует счетный регистр, в котором мы будем хранить значение 2^nΘ :

<p align="center">
 <img src="https://github.com/user-attachments/assets/e6db00bf-cca6-4459-a9a5-52abfb55c280"/>
</p>

2. Суперпозиция:
Применим операцию n-битного вентиля Адамара к счетному регистру:

<p align="center">
 <img src="https://github.com/user-attachments/assets/41f72c37-f62a-458e-903b-070dc0cad067"/>
</p>

3. Контролируемые унитарные операции:
Нам нужно ввести управляемый унитарный CU, который применяет унитарный оператор U к целевому регистру, только если его соответствующий управляющий бит равен |1⟩. Поскольку U является унитарным оператором с собственным вектором |ψ⟩ таким, что U|ψ⟩ = exp(2πιθ)|ψ⟩, это означает:

<p align="center">
 <img src="https://github.com/user-attachments/assets/1521203d-fd91-49d7-97ce-0556b6155f78"/>
</p>

Применяем все n операций CU^(2j) при 0 ≤ j ≤ n−1 и используем соотношение:

<p align="center">
 <img src="https://github.com/user-attachments/assets/7ae6c616-a104-4446-825c-498142f32ad7"/>
</p>

мы получаем

<p align="center">
 <img src="https://github.com/user-attachments/assets/5ec18e39-0e34-4d2d-8f9f-8c441a24ecae"/>
</p>

где k обозначает целочисленное представление n-битных двоичных чисел.

Обратное преобразование Фурье: Обратите внимание, что приведенное выше выражение является точным результатом применения квантового преобразования Фурье, которое мы вывели ранее. Напомним, что QFT отображает n-кубитное входное состояние |x⟩ в выходное как:

<p align="center">
 <img src="https://github.com/user-attachments/assets/f1ce1b06-db2a-41d9-ae8d-581d4bd1e01c"/>
</p>

Замена x на 2^nθ в приведенном выше выражении дает в точности выражение, полученное на шаге 2 выше. Поэтому, чтобы восстановить состояние |2^nθ⟩, применим обратное преобразование Фурье к вспомогательному регистру. Сделав это, мы находим

<p align="center">
 <img src="https://github.com/user-attachments/assets/586fbd64-b2e9-493e-8ac9-611ace433332"/>
</p>

4. Измерение:
Вышеприведенное выражение достигает экстремума вблизи x = 2^nθ . Для случая, когда 2^nθ является целым числом, измерение в вычислительном базисе дает фазу во вспомогательном регистре с высокой вероятностью:

<p align="center">
 <img src="https://github.com/user-attachments/assets/4e0abea8-3f04-4c3a-862e-2ee649355b4b"/>
</p>

Для случая, когда 2^nθ не является целым числом, можно показать, что приведенное выше выражение по-прежнему достигает экстремума вблизи x = 2^nθ с вероятностью лучше, чем 4/π^2=40%.

### Пример 1: Т-вентиль

Давайте возьмем хорошо знакомый нам вентиль T и применим квантовую оценку фазы для оценки его фазы. Вы помните, что T-вентиль добавляет фазу exp(ιπ/4) к состоянию |1⟩:

<p align="center">
 <img src="https://github.com/user-attachments/assets/785b792b-b33d-4d6b-8963-b9a61829af0c"/>
</p>

Так как QPE даст нам θ, где

<p align="center">
 <img src="https://github.com/user-attachments/assets/be191e97-f63e-4821-8965-a08ea32b13db"/>
</p>

Мы ожидаем найти:

<p align="center">
 <img src="https://github.com/user-attachments/assets/d902d064-4872-4c21-a2ba-83defbd7a72d"/>
</p>

В этом примере мы будем использовать три кубита и получим точный результат (не оценку!)

Создание схемы
Давайте сначала подготовим нашу среду:

```
#initialization
import matplotlib.pyplot as plt
import numpy as np
import math

# importing Qiskit
from qiskit import IBMQ, Aer, transpile, assemble
from qiskit import QuantumCircuit, ClassicalRegister, QuantumRegister

# import basic plot tools and circuits
from qiskit.visualization import plot_histogram
from qiskit.circuit.library import QFT
```

Теперь настроим квантовую схему. Мы будем использовать четыре кубита — кубиты с 0 по 2 как счетные кубиты и кубит 3 как собственное состояние унитарного оператора (T).

Мы инициализируем |ψ⟩ = |1⟩, применяя X-вентиль:

```
qpe = QuantumCircuit(4, 3)
qpe.x(3)
qpe.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/75a0b50f-93d7-47d7-a840-8d6b6dfcc5dd"/>
</p>

Далее мы применяем вентили Адамара к счетным кубитам:

```
for qubit in range(3):
    qpe.h(qubit)
qpe.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/8ffdcf83-e56c-4416-8f17-7bad854d0ae6"/>
</p>

Далее мы выполняем контролируемые унитарные операции.

Мы будем использовать Qiskit PhaseGate для создания операции T. Фазовый вентиль выполняет преобразование

<p align="center">
 <img src="https://github.com/user-attachments/assets/102899e1-ee7a-4931-880c-5ef6e5b216be"/>
</p>

,где λ — это угол, который мы предоставляем. Поскольку мы хотим реализовать T, который выполняет

<p align="center">
 <img src="https://github.com/user-attachments/assets/a118603d-9641-4229-aaee-f47c096ec519"/>
</p>

нам нужно установить λ = π/4.

Также помните, что Qiskit упорядочивает свои кубиты в порядке, противоположном схеме в обзоре.

```
qpe.barrier()
# Apply inverse QFT
qpe = qpe.compose(QFT(3, inverse=True), [0,1,2])
# Measure
qpe.barrier()
for n in range(3):
    qpe.measure(n,n)

qpe.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/33cd42e0-c3ac-433f-91b4-1ce89cc28e85"/>
</p>

Результаты: 

```
aer_sim = Aer.get_backend('aer_simulator')
shots = 2048
t_qpe = transpile(qpe, aer_sim)
results = aer_sim.run(t_qpe, shots=shots).result()
answer = results.get_counts()

plot_histogram(answer)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/9d10c6fa-fa41-40af-8a33-2d08385ce42b"/>
</p>

Мы видим, что с уверенностью получаем один результат (001), который переводится в десятичную дробь: 1. Теперь нам нужно разделить наш результат на 2^n, чтобы получить θ:

<p align="center">
 <img src="https://github.com/user-attachments/assets/7f5aa2ab-29c0-4776-8912-fcb6fbd39cd4"/>
</p>

Это именно тот результат, которого мы ожидали!

### Пример 2: Получение большей точности
#### Проблема
Вместо Т вентиля давайте используем вентиль с θ=1/3.

В ячейке ниже мы настраиваем нашу схему так же, как и в предыдущем примере.

Мы снова воспользуемся Qiskit PhaseGate, который делает

<p align="center">
 <img src="https://github.com/user-attachments/assets/3c9b6045-9cc7-4b69-8fb9-1b7bfa791020"/>
</p>

Поскольку мы хотим реализовать

<p align="center">
 <img src="https://github.com/user-attachments/assets/ec2373cd-2f09-45cb-a01a-5f98d3513555"/>
</p>

, нам нужно установить λ = 2π/3 .

```
# Create and set up circuit
qpe2 = QuantumCircuit(4, 3)

# Apply H-Gates to counting qubits:
for qubit in range(3):
    qpe2.h(qubit)

# Prepare our eigenstate |psi>:
qpe2.x(3)

# Do the controlled-U operations:
angle = 2*math.pi/3
repetitions = 1
for counting_qubit in range(3):
    for i in range(repetitions):
        qpe2.cp(angle, counting_qubit, 3);
    repetitions *= 2

# Do the inverse QFT:
qpe2 = qpe2.compose(QFT(3, inverse=True), [0,1,2])

# Measure of course!
for n in range(3):
    qpe2.measure(n,n)

qpe2.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/2f58769e-1ab2-4024-b925-d6c77a3714e0"/>
</p>

```
aer_sim = Aer.get_backend('aer_simulator')
shots = 4096
t_qpe2 = transpile(qpe2, aer_sim)
results = aer_sim.run(t_qpe2, shots=shots).result()
answer = results.get_counts()

plot_histogram(answer)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/dc9fe00b-892b-4e5d-92f9-721b6f08845b"/>
</p>

Мы ожидаем результат θ = 0.33333, и мы видим, что наши наиболее вероятные результаты 010(bin) = 2(dec) и 011(bin) = 3(dec). Эти два результата говорят нам, что θ = 0.25 (смещение на 25%) и θ = 0.375 (смещение на 13%) соответственно. Истинное значение θ лежит между значениями, которые мы можем получить из наших счетных битов, и это дает нам неопределенность и неточность.

#### Решение
Чтобы получить большую точность, мы просто добавляем больше счетных кубитов. Мы собираемся добавить еще два счетных кубита:

```
# Create and set up circuit
qpe3 = QuantumCircuit(6, 5)

# Apply H-Gates to counting qubits:
for qubit in range(5):
    qpe3.h(qubit)

# Prepare our eigenstate |psi>:
qpe3.x(5)

# Do the controlled-U operations:
angle = 2*math.pi/3
repetitions = 1
for counting_qubit in range(5):
    for i in range(repetitions):
        qpe3.cp(angle, counting_qubit, 5);
    repetitions *= 2

# Do the inverse QFT:
qpe3 = qpe3.compose(QFT(5, inverse=True), range(5))

# Measure of course!
qpe3.barrier()
for n in range(5):
    qpe3.measure(n,n)

qpe3.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/8d9ecb91-8523-451b-8953-96ec4ac181fc"/>
</p>

```
aer_sim = Aer.get_backend('aer_simulator')
shots = 4096
t_qpe3 = transpile(qpe3, aer_sim)
results = aer_sim.run(t_qpe3, shots=shots).result()
answer = results.get_counts()

plot_histogram(answer)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/b1daf1f8-b319-453d-a7ea-ab83801bf568"/>
</p>

Два наиболее вероятных измерения теперь 01011 (десятичное 11) и 01010 (десятичное 10). Измерение этих результатов скажет нам, что θ составляет:

<p align="center">
 <img src="https://github.com/user-attachments/assets/4cda36ce-8e97-44a3-9caf-52b57a93dbe6"/>
</p>

Эти два результата отличаются от 1/3 на 3% и 6% соответственно. Гораздо лучшая точность!

### Реальный квантовый компьютер
Мы можем запустить эту схему на реальном устройстве, давайте вспомним схему:

```
qpe.draw('mpl')
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/3dae3e04-8425-40c4-a9d3-6d1220dd5980"/>
</p>

```
from qiskit import IBMQ
IBMQ.save_account('ENTER API TOKEN HERE')
```

```
from qiskit.providers.ibmq import least_busy
IBMQ.load_account()
from qiskit.tools.monitor import job_monitor
provider = IBMQ.get_provider(hub='ibm-q')
backend = least_busy(provider.backends(filters=lambda x: x.configuration().n_qubits >= (n+1) and
                                   not x.configuration().simulator and x.status().operational==True))
print("least busy backend: ", backend)
```

```
# Run with 2048 shots
shots = 2048
t_qpe = transpile(qpe, backend, optimization_level=3)
job = backend.run(t_qpe, shots=shots)
job_monitor(job)
```

```
# get the results from the computation
results = job.result()
answer = results.get_counts(qpe)

plot_histogram(answer)
```

<p align="center">
 <img src="https://github.com/user-attachments/assets/3e43ea07-ff94-4827-94ef-46e44a7dbef4"/>
</p>

Мы можем увидеть, что наиболее вероятным результатом будет 001, что является результатом, который мы ожидаем от симулятора. В отличие от симулятора, существует вероятность измерения чего-то иного, чем 001, это связано с шумом и ошибками вентиля в квантовом компьютере.

# Часть IV. Заключение.

На этом все. Гайд получился небольшим, но поскольку работа велась лишь одним человеком в свободное от других дел время, то это вполне себе неплохо =-) 

Сам проект на этом не заканчивается и я надеюсь, что он будет развиваться и дальше - если не мной, то другими. На данном этапе с моей точки зрения есть еще пару моментов, которые можно было бы сделать лучше, расписать подробнее, привести больше примеров и прочее:

1) Часть с математическими представлениями кубитов оказалась довольно скудной на формулы и почти непонятной для новичка. Я думаю, что было бы здорово дополнить ее, сделать более понятной для новичка.
  
2) Алгоритмы. Их много и предназначены они для всяких разных дел. Самую обширную область в этом занимают алгоритмы, связанные с криптографией и расшифровкой сообщений. Интересно было бы взглянуть на применение подобных алгоритмов для расшифровки сообщений.

3) Вентили. Еще одна часть гайда, которая была обделена математикой. Необходимо дополнить, чтобы было понятнее откуда все берется.

4) Больше тестов, больше примеров! Есть и другие сайты с симуляцией квантовых алгоритмов, которые были обделены вниманием в рамках этого гайда. Было бы неплохо добавить и показать принципы работы алгоритмов на них в том числе.

### Ссылки на ресурсы, которыми я пользовался:
1) https://habr.com/ru/articles/480480/
2) https://learn.microsoft.com/ru-ru/azure/quantum/overview-understanding-quantum-computing
3) https://habr.com/ru/companies/microsoft/articles/351622/
4) https://quantum-ods.github.io/qmlcourse/book/index.html
5) https://habr.com/ru/articles/338202/
6) https://vas3k.blog/blog/quantum_computing/
7) https://github.com/MonitSharma/Learn-Quantum-Computing-with-Qiskit

   . . . 
и огромное множество других статей на Хабре, видеороликов на YouTube и множество других различных сайтов и проектов на GitHub.

А также песочницы, симуляторы и библиотеки, с помощью которых можно протестировать работу разных алгоритмов:
1) https://www.quantumplayground.net/#/home
2) https://azure.microsoft.com/ru-ru/products/quantum
3) https://aws.amazon.com/ru/braket/
4) https://algassert.com/quirk
5) https://github.com/quantumlib/stim/
6) https://algassert.com/crumble
